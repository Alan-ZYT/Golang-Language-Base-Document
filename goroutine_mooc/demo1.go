/*
	下面的程序开了1000个goroutine，执行程序啥也没有输出？
	因为程序是并发执行的，main(主goroutine) 和子(goroutine) 是并发执行的，子go程来不及print内容，
	main函数 for 0-10结束了，然后main就退出了，Go语言的程序一旦main退出了，
	所有的子goroutine就被杀掉了，所以子goroutine还没来得及输出内容就已经被干掉了
	这个main就退出了，程序就结束了

	想要看到效果，保证 main 不要急着退出

	Waht？ 1000个go程

	前提熟悉操作系统：进程和线程
	开10个线程，没有问题，开100个线程，其实也没有大问题，但已经差不多了，
	一般操作系统开几十个;上百个线程就很不错了，1000个的话，1000个人要并发的去执行一些任务，
	这种情况不能简单的通过线程来做到，（其它语言，异步IO的方法）
	在Go语言中，不用管（调度器完成），10个能做，1000个也能做，再多也能做，只需函数前面加 go 关键字就可以并发执行。

## goroutine(go程) VS Coroutinr(协程)
	goroutine 其实是一种协程，或者说它和Coroutinr是比较像的

## 协程和线程关系？
	协程是轻量级的”线程“，它的作用组看起来和线程差不多，都是用来并发执行一些任务的，但是协程是轻量级的；
	随手开1000个协程都没有问题，1000个线程就比较重了。

##	协程为什么是轻量级呢？
	协程是非抢占式多任务处理，由协程主动交出控制权

##	非抢占式？
 	线程在任何时候会被操作系统进行切换，线程是抢占式多任务处理，没有控制权；
	做到一半，哪怕一个语句执行到一半，都会被操作系统中间掐掉，切换到其它线程里面去，操作系统以后还会回来；

	但协程不一样，协程是非抢占式多任务处理，什么时候想交出控制权，什么时候不想交出控制权，是由协程内部主动决定的；
	正式因为非抢占式，所以它才能做到轻量级，抢占式要做出最坏的情况，去抢的时候，别人正好做到一半，那我要存更多的数据；
	上下文要存的更多，而非抢占式呢，只需处理切换的几个点就可以了，对资源的消耗会少一些。

## goroutine可能的切换点，注意：以下为参考
	I/O，select
	channel
	等待锁
	函数调用
	runtime.Gosched() //手动方式

## 编译器/解释器/虚拟机层面的多任务
	它是编译器、解释器或者虚拟机层面的多任务，它不是一个操作系统层面的多任务，操作系统其中只有线程，没有协程；
	在Go语言中，一方面可以看作是编译器级别的多任务，编译器会把一个 go func(){} 解释成一个协程；
	具体在执行上，Go语言后面有一个调度器来调度协程，操作系统本身的调度器，Go语言程序里面还有自己的调度器。

## 因此多个协程可以在一个或者多个线程上运行，这个是由调度器决定的。
*/

package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 0; i < 1000; i++ {
		go func(i int) {
			for {
				// 抢占式，Printf 是一个I/O操作，会在I/O操作里面进行切换，因为I/O操作总会有等待的过程
				fmt.Printf("Hello from goroutine %d\n", i)
			}
		}(i)
	}
	time.Sleep(time.Minute)
}
